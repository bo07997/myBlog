---
layout: post
title:  "设计模式六大原则"
date:   2020-05-18 15:02:23
comments: false
categories: 设计模式
tag: 设计模式
description:  《设计模式之禅》学习笔记,最近接触到很多设计方面的问题,于是乎想整理一下这一块的知识。                                                        
---
* content
{:toc}
##### introduction

《设计模式之禅》的学习

## 单一职责原则

##### 定义:SRP的原话解释是：There should never be more than one reason for a class to change.

对于接口， 我们在设计的时候一定要做到单一， 但是对于实现类就需要多方面考虑了。
生搬硬套单一职责原则会引起类的剧增， 给维护带来非常多的麻烦， 而且过分细分类的职责也会人为地增加系统的复杂性。 本来一个类可以实现的行为硬要拆成两个类， 然后再使用聚
合或组合的方式耦合在一起， 人为制造了系统的复杂性。 所以原则是死的， 人是活的， 这句话很有道理。

对于单一职责原则， 我的建议是接口一定要做到单一职责， 类的设计尽量做到只有一个原因引起变化。


## 开闭原则
#####定义:
Software entities like classes,modules and functions should be open for extension but closed for
modifications.（一个软件实体如类、 模块和函数应该对扩展开放， 对修改关闭。 ）

![](https://bo07997.github.io/myBlog/styles/images/Blog/设计模式六大原则/1.png)

如上图所示,OffNovelBook类继承了NovelBook， 并覆写了getPrice方法，不修改原有的代码。仅仅覆写了getPrice方法， 通过扩展完成了新增加的业务。

注意 开闭原则对扩展开放， 对修改关闭， 并不意味着不做任何修改， 低层模块的变更， 必然要有高层模块进行耦合， 否则就是一个孤立无意义的代码片段。

## 里氏替换原则

##### 定义:

● 第一种定义， 也是最正宗的定义： If for each object o1 of type S there is an object o2 of
type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is
substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1， 都有类型为T的对
象o2， 使得以T定义的所有程序P在所有的对象o1都代换成o2时， 程序P的行为没有发生变
化， 那么类型S是类型T的子类型。 ）

● 第二种定义： Functions that use pointers or references to base classes must be able to use
objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的
对象。 ）

第二个定义是最清晰明确的， 通俗点讲， 只要父类能出现的地方子类就可以出现， 而且
替换为子类也不会产生任何错误或异常， 使用者可能根本就不需要知道是父类还是子类。 但
是， 反过来就不行了， 有子类出现的地方， 父类未必就能适应。

在面向对象的语言中， 继承是必不可少的、 非常优秀的语言机制， 它有如下优点：

● 代码共享， 减少创建类的工作量， 每个子类都拥有父类的方法和属性；

● 提高代码的重用性；

● 子类可以形似父类， 但又异于父类， “龙生龙， 凤生凤， 老鼠生来会打洞”是说子拥有
父的“种”， “世界上没有两片完全相同的叶子”是指明子与父的不同；

● 提高代码的可扩展性， 实现父类的方法就可以“为所欲为”了， 君不见很多开源框架的
扩展接口都是通过继承父类来完成的；

● 提高产品或项目的开放性。
自然界的所有事物都是优点和缺点并存的， 即使是鸡蛋， 有时候也能挑出骨头来， 继承
的缺点如下：

● 继承是侵入性的。 只要继承， 就必须拥有父类的所有属性和方法；

● 降低代码的灵活性。 子类必须拥有父类的属性和方法， 让子类自由的世界中多了些约
束；

● 增强了耦合性。 当父类的常量、 变量和方法被修改时， 需要考虑子类的修改， 而且在
缺乏规范的环境下， 这种修改可能带来非常糟糕的结果——大段的代码需要重构。

##### 1.子类必须完全实现父类的方法

如果子类不能完整地实现父类的方法， 或者父类的某些方法在子类中已经发
生“畸变”， 则建议断开父子继承关系， 采用依赖、 聚集、 组合等关系代替继承。

##### 2.子类可以有自己的个性

##### 3.覆盖或实现父类的方法时输入参数可以被放大（重载）
不然会导致：子类在没有覆写父类的方法的前提下， 子类方法被执行了， 这会引起业务
逻辑混乱， 因为在实际应用中父类一般都是抽象类， 子类是实现类， 你传递一个这样的实现
类就会“歪曲”了父类的意图， 引起一堆意想不到的业务逻辑混乱， 所以子类中方法的前置条
件必须与超类中被覆写的方法的前置条件相同或者更宽松。

##### 4. 覆写或实现父类的方法时输出结果可以被缩小（覆写）

##### 总结

在项目中， 采用里氏替换原则时， 尽量避免子类的“个性”， 一旦子类有“个性”， 这个子
类和父类之间的关系就很难调和了， 把子类当做父类使用， 子类的“个性”被抹杀——委屈了
点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替
换的标准。

## 接口隔离原则


## 依赖倒置原则

##### 定义:
High level modules should not depend upon low level modules.Both should depend upon
abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.

翻译过来， 包含三层含义：
● 高层模块不应该依赖低层模块， 两者都应该依赖其抽象；
● 抽象不应该依赖细节；
● 细节应该依赖抽象。

依赖倒置原则在Java语言中的表现就是：
● 模块间的依赖通过抽象发生， 实现类之间不发生直接的依赖关系， 其依赖关系是通过
接口或抽象类产生的；
● 接口或抽象类不依赖于实现类；
● 实现类依赖接口或抽象类。

更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design， 面向对象设
计） 的精髓之一。



